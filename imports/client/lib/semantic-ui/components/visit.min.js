/*!
 * # Semantic UI 2.0.0 - Visit
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Copyright 2015 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function(e, t, i, n) {
    e.visit = e.fn.visit = function(i) {
        let o; const r = e(e.isFunction(this) ? t : this); const s = r.selector || ''; let a = (new Date()).getTime(); let c = []; const u = arguments[0]; const l = typeof u === 'string'; const d = [].slice.call(arguments, 1); return r.each(function() {
            let g; const m = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.visit.settings, i) : e.extend({}, e.fn.visit.settings); const f = m.error; const p = m.namespace; const v = `${p}-module`; const h = e(this); let b = e(); const y = this; let k = h.data(v); g = {
                initialize() { m.count ? g.store(m.key.count, m.count) : m.id ? g.add.id(m.id) : m.increment && l !== 'increment' && g.increment(), g.add.display(h), g.instantiate(); },
                instantiate() { g.verbose('Storing instance of visit module', g), k = g, h.data(v, g); },
                destroy() { g.verbose('Destroying instance'), h.removeData(v); },
                increment(e) { const t = g.get.count(); let i = +t + 1; e ? g.add.id(e) : (i > m.limit && !m.surpass && (i = m.limit), g.debug('Incrementing visits', i), g.store(m.key.count, i)); },
                decrement(e) { const t = g.get.count(); const i = +t - 1; e ? g.remove.id(e) : (g.debug('Removing visit'), g.store(m.key.count, i)); },
                get: {
                    count() { return +g.retrieve(m.key.count) || 0; }, idCount(e) { return e = e || g.get.ids(), e.length; }, ids(e) { let t = []; return e = e || g.retrieve(m.key.ids), typeof e === 'string' && (t = e.split(m.delimiter)), g.verbose('Found visited ID list', t), t; }, storageOptions(e) { const t = {}; return m.expires && (t.expires = m.expires), m.domain && (t.domain = m.domain), m.path && (t.path = m.path), t; },
                },
                has: { visited(t, i) { let o = !1; return i = i || g.get.ids(), t !== n && i && e.each(i, function(e, i) { i == t && (o = !0); }), o; } },
                set: { count(e) { g.store(m.key.count, e); }, ids(e) { g.store(m.key.ids, e); } },
                reset() { g.store(m.key.count, 0), g.store(m.key.ids, null); },
                add: { id(e) { const t = g.retrieve(m.key.ids); const i = t === n || t === '' ? e : t + m.delimiter + e; g.has.visited(e) ? g.debug('Unique content already visited, not adding visit', e, t) : e === n ? g.debug('ID is not defined') : (g.debug('Adding visit to unique content', e), g.store(m.key.ids, i)), g.set.count(g.get.idCount()); }, display(t) { const i = e(t); i.length > 0 && !e.isWindow(i[0]) && (g.debug('Updating visit count for element', i), b = b.length > 0 ? b.add(i) : i); } },
                remove: { id(t) { const i = g.get.ids(); let o = []; t !== n && i !== n && (g.debug('Removing visit to unique content', t, i), e.each(i, function(e, i) { i !== t && o.push(i); }), o = o.join(m.delimiter), g.store(m.key.ids, o)), g.set.count(g.get.idCount()); } },
                check: { limit(e) { e = e || g.get.count(), m.limit && (e >= m.limit && (g.debug('Pages viewed exceeded limit, firing callback', e, m.limit), m.onLimit.call(y, e)), g.debug('Limit not reached', e, m.limit), m.onChange.call(y, e)), g.update.display(e); } },
                update: { display(e) { e = e || g.get.count(), b.length > 0 && (g.debug('Updating displayed view count', b), b.html(e)); } },
                store(i, o) { const r = g.get.storageOptions(o); if (m.storageMethod == 'localstorage' && t.localStorage !== n)t.localStorage.setItem(i, o), g.debug('Value stored using local storage', i, o); else { if (e.cookie === n) return void g.error(f.noCookieStorage); e.cookie(i, o, r), g.debug('Value stored using cookie', i, o, r); }i == m.key.count && g.check.limit(o); },
                retrieve(i, o) { let r; return m.storageMethod == 'localstorage' && t.localStorage !== n ? r = t.localStorage.getItem(i) : e.cookie !== n ? r = e.cookie(i) : g.error(f.noCookieStorage), (r == 'undefined' || r == 'null' || r === n || r === null) && (r = n), r; },
                setting(t, i) { if (e.isPlainObject(t))e.extend(!0, m, t); else { if (i === n) return m[t]; m[t] = i; } },
                internal(t, i) { return g.debug('Changing internal', t, i), i === n ? g[t] : void (e.isPlainObject(t) ? e.extend(!0, g, t) : g[t] = i); },
                debug() { m.debug && (m.performance ? g.performance.log(arguments) : (g.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), g.debug.apply(console, arguments))); },
                verbose() { m.verbose && m.debug && (m.performance ? g.performance.log(arguments) : (g.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), g.verbose.apply(console, arguments))); },
                error() { g.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), g.error.apply(console, arguments); },
                performance: {
                    log(e) {
                        let t; let i; let n; m.performance && (t = (new Date()).getTime(), n = a || t, i = t - n, a = t, c.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: y, 'Execution Time': i,
                        })), clearTimeout(g.performance.timer), g.performance.timer = setTimeout(g.performance.display, 500);
                    },
                    display() { let t = `${m.name}:`; let i = 0; a = !1, clearTimeout(g.performance.timer), e.each(c, function(e, t) { i += t['Execution Time']; }), t += ` ${i}ms`, s && (t += ` '${s}'`), r.length > 1 && (t += ` (${r.length})`), (console.group !== n || console.table !== n) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), c = []; },
                },
                invoke(t, i, r) { let s; let a; let c; let u = k; return i = i || d, r = y || r, typeof t === 'string' && u !== n && (t = t.split(/[\. ]/), s = t.length - 1, e.each(t, function(i, o) { const r = i != s ? o + t[i + 1].charAt(0).toUpperCase() + t[i + 1].slice(1) : t; if (e.isPlainObject(u[r]) && i != s)u = u[r]; else { if (u[r] !== n) return a = u[r], !1; if (!e.isPlainObject(u[o]) || i == s) return u[o] !== n ? (a = u[o], !1) : !1; u = u[o]; } })), e.isFunction(a) ? c = a.apply(r, i) : a !== n && (c = a), e.isArray(o) ? o.push(c) : o !== n ? o = [o, c] : c !== n && (o = c), a; },
            }, l ? (k === n && g.initialize(), g.invoke(u)) : (k !== n && k.invoke('destroy'), g.initialize());
        }), o !== n ? o : this;
    }, e.fn.visit.settings = {
        name: 'Visit', debug: !1, verbose: !1, performance: !0, namespace: 'visit', increment: !1, surpass: !1, count: !1, limit: !1, delimiter: '&', storageMethod: 'localstorage', key: { count: 'visit-count', ids: 'visit-ids' }, expires: 30, domain: !1, path: '/', onLimit() {}, onChange() {}, error: { method: 'The method you called is not defined', missingPersist: 'Using the persist setting requires the inclusion of PersistJS', noCookieStorage: 'The default storage cookie requires $.cookie to be included.' },
    };
}(jQuery, window, document));
