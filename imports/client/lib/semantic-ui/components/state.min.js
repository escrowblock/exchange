!(function(e, t, n, a) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.state = function(t) {
        let i; const o = e(this); const s = o.selector || ''; let c = (n.documentElement, (new Date()).getTime()); let r = []; const l = arguments[0]; const u = typeof l === 'string'; const d = [].slice.call(arguments, 1); return o.each(function() {
            let n; const f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.state.settings, t) : e.extend({}, e.fn.state.settings); const v = f.error; const g = f.metadata; const b = f.className; const x = f.namespace; const h = f.states; const m = f.text; const p = `.${x}`; const T = `${x}-module`; let y = e(this); const w = this; let C = y.data(T); n = {
                initialize() { n.verbose('Initializing module'), f.automatic && n.add.defaults(), f.context && s !== '' ? e(f.context).on(s, `mouseenter${p}`, n.change.text).on(s, `mouseleave${p}`, n.reset.text).on(s, `click${p}`, n.toggle.state) : y.on(`mouseenter${p}`, n.change.text).on(`mouseleave${p}`, n.reset.text).on(`click${p}`, n.toggle.state), n.instantiate(); },
                instantiate() { n.verbose('Storing instance of module', n), C = n, y.data(T, n); },
                destroy() { n.verbose('Destroying previous module', C), y.off(p).removeData(T); },
                refresh() { n.verbose('Refreshing selector cache'), y = e(w); },
                add: { defaults() { const i = t && e.isPlainObject(t.states) ? t.states : {}; e.each(f.defaults, function(t, o) { n.is[t] !== a && n.is[t]() && (n.verbose('Adding default states', t, w), e.extend(f.states, o, i)); }); } },
                is: {
                    active() { return y.hasClass(b.active); }, loading() { return y.hasClass(b.loading); }, inactive() { return !y.hasClass(b.active); }, state(e) { return b[e] !== a && y.hasClass(b[e]); }, enabled() { return !y.is(f.filter.active); }, disabled() { return y.is(f.filter.active); }, textEnabled() { return !y.is(f.filter.text); }, button() { return y.is('.button:not(a, .submit)'); }, input() { return y.is('input'); }, progress() { return y.is('.ui.progress'); },
                },
                allow(e) { n.debug('Now allowing state', e), h[e] = !0; },
                disallow(e) { n.debug('No longer allowing', e), h[e] = !1; },
                allows(e) { return h[e] || !1; },
                enable() { y.removeClass(b.disabled); },
                disable() { y.addClass(b.disabled); },
                setState(e) { n.allows(e) && y.addClass(b[e]); },
                removeState(e) { n.allows(e) && y.removeClass(b[e]); },
                toggle: { state() { let t; if (n.allows('active') && n.is.enabled()) { if (n.refresh(), e.fn.api !== a) if (t = y.api('get request'), y.api('was cancelled'))n.debug('API Request cancelled by beforesend'), f.activateTest = function() { return !1; }, f.deactivateTest = function() { return !1; }; else if (t) return void n.listenTo(t); n.change.state(); } } },
                listenTo(t) { n.debug('API request detected, waiting for state signal', t), t && (m.loading && n.update.text(m.loading), e.when(t).then(function() { t.state() == 'resolved' ? (n.debug('API request succeeded'), f.activateTest = function() { return !0; }, f.deactivateTest = function() { return !0; }) : (n.debug('API request failed'), f.activateTest = function() { return !1; }, f.deactivateTest = function() { return !1; }), n.change.state(); })); },
                change: { state() { n.debug('Determining state change direction'), n.is.inactive() ? n.activate() : n.deactivate(), f.sync && n.sync(), f.onChange.call(w); }, text() { n.is.textEnabled() && (n.is.disabled() ? (n.verbose('Changing text to disabled text', m.hover), n.update.text(m.disabled)) : n.is.active() ? m.hover ? (n.verbose('Changing text to hover text', m.hover), n.update.text(m.hover)) : m.deactivate && (n.verbose('Changing text to deactivating text', m.deactivate), n.update.text(m.deactivate)) : m.hover ? (n.verbose('Changing text to hover text', m.hover), n.update.text(m.hover)) : m.activate && (n.verbose('Changing text to activating text', m.activate), n.update.text(m.activate))); } },
                activate() { f.activateTest.call(w) && (n.debug('Setting state to active'), y.addClass(b.active), n.update.text(m.active), f.onActivate.call(w)); },
                deactivate() { f.deactivateTest.call(w) && (n.debug('Setting state to inactive'), y.removeClass(b.active), n.update.text(m.inactive), f.onDeactivate.call(w)); },
                sync() { n.verbose('Syncing other buttons to current state'), n.is.active() ? o.not(y).state('activate') : o.not(y).state('deactivate'); },
                get: { text() { return f.selector.text ? y.find(f.selector.text).text() : y.html(); }, textFor(e) { return m[e] || !1; } },
                flash: { text(e, t, a) { const i = n.get.text(); n.debug('Flashing text message', e, t), e = e || f.text.flash, t = t || f.flashDuration, a = a || function() {}, n.update.text(e), setTimeout(function() { n.update.text(i), a.call(w); }, t); } },
                reset: { text() { const e = m.active || y.data(g.storedText); const t = m.inactive || y.data(g.storedText); n.is.textEnabled() && (n.is.active() && e ? (n.verbose('Resetting active text', e), n.update.text(e)) : t && (n.verbose('Resetting inactive text', e), n.update.text(t))); } },
                update: { text(e) { const t = n.get.text(); e && e !== t ? (n.debug('Updating text', e), f.selector.text ? y.data(g.storedText, e).find(f.selector.text).text(e) : y.data(g.storedText, e).html(e)) : n.debug('Text is already set, ignoring update', e); } },
                setting(t, i) { if (n.debug('Changing setting', t, i), e.isPlainObject(t))e.extend(!0, f, t); else { if (i === a) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], i) : f[t] = i; } },
                internal(t, i) { if (e.isPlainObject(t))e.extend(!0, n, t); else { if (i === a) return n[t]; n[t] = i; } },
                debug() { !f.silent && f.debug && (f.performance ? n.performance.log(arguments) : (n.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), n.debug.apply(console, arguments))); },
                verbose() { !f.silent && f.verbose && f.debug && (f.performance ? n.performance.log(arguments) : (n.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), n.verbose.apply(console, arguments))); },
                error() { f.silent || (n.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), n.error.apply(console, arguments)); },
                performance: {
                    log(e) {
                        let t; let a; f.performance && (a = (t = (new Date()).getTime()) - (c || t), c = t, r.push({
                            Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: w, 'Execution Time': a,
                        })), clearTimeout(n.performance.timer), n.performance.timer = setTimeout(n.performance.display, 500);
                    },
                    display() { let t = `${f.name}:`; let i = 0; c = !1, clearTimeout(n.performance.timer), e.each(r, function(e, t) { i += t['Execution Time']; }), t += ` ${i}ms`, s && (t += ` '${s}'`), (console.group !== a || console.table !== a) && r.length > 0 && (console.groupCollapsed(t), console.table ? console.table(r) : e.each(r, function(e, t) { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), r = []; },
                },
                invoke(t, o, s) { let c; let r; let l; let u = C; return o = o || d, s = w || s, typeof t === 'string' && u !== a && (t = t.split(/[\. ]/), c = t.length - 1, e.each(t, function(i, o) { const s = i != c ? o + t[i + 1].charAt(0).toUpperCase() + t[i + 1].slice(1) : t; if (e.isPlainObject(u[s]) && i != c)u = u[s]; else { if (u[s] !== a) return r = u[s], !1; if (!e.isPlainObject(u[o]) || i == c) return u[o] !== a ? (r = u[o], !1) : (n.error(v.method, t), !1); u = u[o]; } })), e.isFunction(r) ? l = r.apply(s, o) : r !== a && (l = r), e.isArray(i) ? i.push(l) : i !== a ? i = [i, l] : l !== a && (i = l), r; },
            }, u ? (C === a && n.initialize(), n.invoke(l)) : (C !== a && C.invoke('destroy'), n.initialize());
        }), i !== a ? i : this;
    }, e.fn.state.settings = {
        name: 'State',
        debug: !1,
        verbose: !1,
        namespace: 'state',
        performance: !0,
        onActivate() {},
        onDeactivate() {},
        onChange() {},
        activateTest() { return !0; },
        deactivateTest() { return !0; },
        automatic: !0,
        sync: !1,
        flashDuration: 1e3,
        filter: { text: '.loading, .disabled', active: '.disabled' },
        context: !1,
        error: { beforeSend: 'The before send function has cancelled state change', method: 'The method you called is not defined.' },
        metadata: { promise: 'promise', storedText: 'stored-text' },
        className: {
            active: 'active', disabled: 'disabled', error: 'error', loading: 'loading', success: 'success', warning: 'warning',
        },
        selector: { text: !1 },
        defaults: {
            input: { disabled: !0, loading: !0, active: !0 },
            button: { disabled: !0, loading: !0, active: !0 },
            progress: {
                active: !0, success: !0, warning: !0, error: !0,
            },
        },
        states: {
            active: !0, disabled: !0, error: !0, loading: !0, success: !0, warning: !0,
        },
        text: {
            disabled: !1, flash: !1, hover: !1, active: !1, inactive: !1, activate: !1, deactivate: !1,
        },
    };
}(jQuery, window, document));
